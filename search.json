[{"title":"一些杂项","url":"/2019/10/08/一些杂项/","content":"\n这一篇主要用来记一些很杂的东西\n\n## 各种碰到过的问题\n\n### 兼容性\n\n#### iphone\n尽量语义化，不要用div充当button标签。\n\ncss中，用animate的话，尽量不要使用使用transform ：translate，使用top：1px；（是的单位最好用px，不然可能动不了）\n\n"},{"title":"vue的数组更新源码解析","url":"/2019/07/13/vue的数组更新源码解析/","content":"# 问题:在vue里如何进行数组更新\nVue的[文档](https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)里已经说明了\n\n由于 JavaScript 的限制，Vue 不能检测以下数组的变动：\n- 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n- 当你修改数组的长度时，例如：vm.items.length = newLength\n\nvue里要让数组更新，使用的是Vue.set方法。\n\n但是网上的很多文章里没有告诉我们Vue.set方法究竟干了什么。\n\n下面我们看源码\n\n# 源码:set部分\nVue2.6的set方法源码：\n```javascript\n/**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set (target, key, val) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n    }\n    if (!ob) {\n      target[key] = val;\n      return val\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val\n  }\n```\n这里只关注关于数组的部分：\n```javascript\nif (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);  //取length和index中大的那一个，这里key是indexOfItem\n      target.splice(key, 1, val);\n      return val\n}\n\n//使用时就是Vue.set(vm.items, indexOfItem, newValue)\n```\n当传入的target是数组且indexOfItem正常时，调用vue包装过的splice方法然后return val。\n\n上面说到vue不能检测数组的变动，set方法其实就是用vue包装过的splice变异方法来进行数组更新。\n\n这里请看vue[变异方法](https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95-mutation-method)的文档\n\n那么splice变异方法又是怎么做到的呢\n\n# 源码：变异方法部分\n\n包装数组方法的源码：\n\n```javascript\nvar methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n];\n\nmethodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    //def函数是vue稍微封装了一下Object.defineProperty\n    def(arrayMethods, method, function mutator () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__; //ob是vue自己封装的observer对象，要想了解请去网上看vue双向绑定源码的解析\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break\n        case 'splice':\n          inserted = args.slice(2);\n          break\n      }\n      if (inserted) { ob.observeArray(inserted); }\n      // notify change\n      ob.dep.notify();\n      return result\n    });\n  });\n```\n\n```javascript\n  Observer.prototype.observeArray = function observeArray (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n```\n\n啊，我看不懂了，还需加强学习，接下来请看[这个大神的文章](https://ustbhuangyi.github.io/vue-analysis/reactive/questions.html#%E6%95%B0%E7%BB%84)\n\n未完待续...","tags":["vue"]},{"title":"写一写吸顶效果的实现","url":"/2019/07/10/写一写吸顶效果的实现/","content":"\n# 什么是吸顶效果\n当我们使用app时，时常会有这样一种场景，一个网页的最上方是一个swipe，然后下面是一个搜索栏，当我们往下滑动网页的时候，swipe会随着滑动消失，而搜索栏却会“粘”在网页最上方，这就是所谓的吸顶效果\n\n# 如何实现\n思路是这样的 获取元素的距离页面最上边的高度，获取浏览器滑动到的高度（也就是scrollTop），然后判断 \n\n当 浏览器滑动到的高度 - 距离页面最上边的高度 > 0 时，给元素加上fixed定位固定，设置css属性 top = 0使其保持在页面最上端。\n\n\n网上有很多种实现方式，其中有些用了offsetTop，让offsetTop - scrollTop\n\n请注意！！！！\n\n- offsetTop像css的absoulte属性一样，是向上找一个position不为static的元素相对定位的，所以有时候会出现bug。\n\n最好的方式是使用原生的api ： object.getBoundingClientRect().top，它一步到位表示的是元素上边到视窗上边的距离。\n\n这样直接判断 object.getBoundingClientRect().top <= 0 就可以了\n\n# 细节\n\n不同浏览器，获取scrollTop的方式是不同的，为了兼容性应该这么写\n\n```javascript\nlet scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop\n```\n\n根据这篇文章[]\n\n\n\n","tags":["javascript","css"]},{"title":"我的前端面试题","url":"/2019/06/29/我的前端面试题/","tags":["面试"]},{"title":"节流函数和防抖函数","url":"/2019/05/26/节流函数和防抖函数/","content":"\n# 介绍\n\n节流和防抖很相似，都是对不断调用的函数的次数进行限制。\n不同之处在于，\n- 节流就像是水龙头，想象一下，把水龙头扭到很小但是水滴还是一滴一滴地流下来，节流函数就是水龙头阀门，限制函数（水滴）的调用次数（滴落频率）\n\n- 防抖函数像是弹簧，只要人一直压着弹簧（一直触发函数），弹簧就不会伸展（函数就不被调用），当人松开的时候（不触发函数了），弹簧就伸展开来了（函数就被调用），即如果一直触发函数，以最后一次为准。\n\n拿页面resize做例子，假设下面这个函数被节流或函数处理过：\n```javascript\nwindow.onresize = function(){\n    console.log('1')\n}\n```\n它们的表现会是：\n- 节流：设定5秒内只能触发一次函数，假设20秒内一直resize,那么控制台只能看到4个 ‘1’\n- 防抖：设定倒数5秒后才触发函数resize，如果期间一直触发resize，则刷新倒数时间从头来过，直到不再触发resize，结果是控制台只能看到1个 ‘1’\n\n# 代码\n\n```javascript\n//防抖\nfunction debounce(fn) {\n  let timeout = null;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn.call(this, arguments);\n    }, 1000);\n  };\n}\n\nlet event = debounce(()=>{\n  console.log('1')\n})\n\nwindow.onresize = event\n```\n\n```javascript\n//节流\nfunction throttle(fn) {\n  let canRun = true;\n  return function() {\n    if(!canRun) {\n      return;\n    }\n    canRun = false;\n    setTimeout( () => {\n      fn.call(this, arguments);\n      canRun = true;\n      }, 1000);\n  };\n}\n\nlet event = throttle(()=>{\n  console.log('1')\n})\n\nwindow.onresize = event\n```","tags":["javascript"]},{"title":"为什么不直接用VW而是用rem？","url":"/2019/05/21/为什么不直接用VW而是用rem？/","content":"\n# 为什么不直接用VW而是用rem？\n\n突然想到了这个问题，自己试着解答一下\n\n## vw和rem的差异\nVW是根据视口宽度而定的,1vw等于视口宽度的1%\nrem则是依据html元素的font-size大小而定，在rem动态方案中，会让html的font-size等于视口宽度，变相实现vw的效果（rem方案一般在窗口resize时会改变html的font-size）\n\nPS:以前我在chrome使用vw，窗口resize，但是vw值并没有改变，现在试了下，vw会随着窗口resize改变。\n\n## rem和vw的兼容性\nrem的兼容性比vw的兼容性好，看下图\n![rem-suit.jpg](为什么不直接用VW而是用rem？/rem-suit.png)\n![vw-suit.jpg](为什么不直接用VW而是用rem？/vw-suit.png)\n\n附录：张鑫旭写的一篇关于vw的文章\nhttps://www.zhangxinxu.com/wordpress/2016/08/vw-viewport-responsive-layout-typography/\n\n","tags":["css","布局"]},{"title":"Vue的双向绑定是怎样实现的","url":"/2019/05/08/Vue的双向绑定是怎样实现的/","content":"\n# 大概思路\nvue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，\n代码大概分为三个部分：Observer、Watcher、Compile\n## Observer\nObserver主要用到了一个api叫 defineProperty，这个方法可以劫持一个对象的属性，操控它的getter和setter\n什么叫getter、setter?看代码。\n```javascript\nvar Book = {}\nvar name = '';\nObject.defineProperty(Book, 'name', {\n  set: function (value) {\n    name = value;\n    console.log('你取了一个书名叫做' + value);\n  },\n  get: function () {\n    return '《' + name + '》'\n  }\n})\n \nBook.name = 'vue权威指南';  // 你取了一个书名叫做vue权威指南\nconsole.log(Book.name);  // 《vue权威指南》\n```\n可以看到，当我们对book的属性name进行赋值时，它会执行\n```javascript\n  set: function (value) {\n    name = value;\n    console.log('你取了一个书名叫做' + value);\n  },\n```\n当我们访问Book.name时，它会执行\n```javascript\n  get: function () {\n    return '《' + name + '》'\n  }\n```\n\n这就是所谓的getter和setter。\n通过这个api我们就可以实现 data 到 view的单向绑定。\n\n### ","tags":["Vue"]},{"title":"关于vue的组件通信","url":"/2019/05/05/关于vue的组件通信/","content":"## 父子间的组件通信\n今天来总结一下Vue中的组件通信,参考了官方教程和某些博客\n父子间的通信有两种，一种是从父到子，另一种是从子到父\n### 从父到子\n一般使用props\n```javascript\nVue.component('blog-post', {\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n\n<blog-post post-title=\"hello!\"></blog-post>\n```\n### 从子到父\n使用emit\n```javascript\n// 父组件\n<single-address @edit-address=\"editAddress\"></single-address>\n```\n```javascript\n// 子组件\nmethods: {\n editAddress () {\n  this.$emit('edit-address', false)\n }\n}\n```\n## 兄弟间的组件通信\n使用event bus\n```javascript\nvar bus = new Vue()\n// 组件A\nbus.$emit('id-selected', 1)\n// 组件B\nbus.$on('id-selected', function (id) {\n console.log(id)\n})\n```\n## 祖孙间的组件通信\n依赖注入,使用 provide 和 inject\n```html\n<!-- 组件结构 -->\n<google-map>\n  <google-map-region v-bind:shape=\"cityBoundaries\">\n    <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n  </google-map-region>\n</google-map>\n```\n\n```javascript\n// 组件google-map内部\n// provide 选项允许我们指定我们想要提供给后代组件的数据/方法。在这个例子中，就是 <google-map> 内部的 getMap 方法\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n```javascript\n//然后在任何后代组件里，我们都可以使用 inject 选项来接收指定的我们想要添加在这个实例上的属性\ninject: ['getMap']\n```\n\n\n## 另外一些方法\n```javascript\n// 根组件\nthis.$root\n```\n```javascript\nthis.$parent\n```\n```javascript\n//注意，是直接子组件\nthis.$children\n```\n```javascript\nthis.$refs\n\nvar req = new XMLhttpRequest()\nreq.open('GET','',true)\nreq.onreadystatechange=function(){\n  if(req.readyState==4&&req.status==200){\n    var str = req.responseText\n    console.log(str)\n  }\n}\n\nreq.send()\n```\n\n\n","tags":["Vue"]},{"title":"vuex初探","url":"/2019/04/27/vuex初探/","content":"## 基础知识\n\n\n\n","tags":["vuex"]},{"title":"三行说明rem自适应布局方案","url":"/2019/04/24/三行说明rem自适应布局方案/","content":"\n## 说明\nrem自适应布局方案，其要点是让css中的rem单位根据页面的宽度的变化而变化\n而 rem 的大小 等于 html的font-size大小。\n\n那么，让 html的font-size 等于 页面的宽度就能实现目标了。\n\n## 代码\n\n```javascript\nlet width = document.documentElement.clientWidth ||document.body.clientWidth\n//这一行获取当前页面的宽度\n\nlet html = document.querySelector('html')\n//这一行获取html dom\n\nhtml.style.fontSize = width /10 + 'px'    \n//这一行把html的fontsize设置成 width的十分之一，使用vw时1vw就等于页面的十分之一宽。\n```\n","tags":["javascript","布局"]},{"title":"js是传值还是传引用?","url":"/2019/04/17/js是传值还是传引用/","content":"# 先说结论\n\n<<javascript高级程序>>这本书上说，javascript是*按值传参*\n\n但是javascript给人的感觉很古怪，一下让人觉得是传值，一下又让人觉得是传引用，name到底是怎么回事呢？\n\n答案是传值。\n\n## 为何\n来看下面几道面试题，首先是基本类型number\n```javascript\n//第一题\nvar a = 1\n\nfunction change1(a){\n    a = 2\n}\n\nconsole.log(a) //输出 1\n```\n\n如果传的是引用，那么a的值就会被改变，很明显是传值，但这是基本类型number，如果是object呢？\n\n```javascript\n//第二题\nvar b = {\n    name:'fire',\n    age:'30',\n}\n\nfunction change2(b){\n    b.name = 'water'\n}\n\nchange2(b)\n\nconsole.log(b.name)  //输出 water\n```\n\n说好的传值呢？怎么b.name被改变了？看下一题\n\n```javascript\n//第三题\nvar b = {\n    name:'fire',\n    age:30,\n}\n\nfunction change3(b){\n    b = {\n        name:'water',\n        age:30,\n    }\n}\n\nchange3(b)\n\nconsole.log(b.name)  //输出 fire\n```\n\n这下看上去还是传值，究竟是咋回事\n\n这是因为js在传object这种复杂类型的时候，传的是 指向object的指针的拷贝\n\n重点 指向object的指针的拷贝\n重点 指向object的指针的拷贝\n重点 指向object的指针的拷贝\n\n所以<<javascript高级程序>>说js是按值传参也没错\n\n因为传的是指针，所以第二题中 给b.name赋值会改变指针指向的对象的值， 函数外面的b的指针也是指向这个对象，所以值会改变\n\n第三题中，change函数里的b被赋予一个新的对象，等于改变指针指向为一个新的对象，而不是改变旧对象里的值，所以外面的b的值还是fire\n\n## 总结\n\n复杂对象如object是传的指针的拷贝，也是传值\n简单对象如number是传值\n\n","tags":["javascript"]},{"title":"event-loop，微任务与宏任务","url":"/2019/04/14/event-loop，微任务与宏任务/","content":"\n## 代码为啥会这样？\n\n很多时候我都对下列代码一脸懵逼\n\n```javascript\nsetTimeout(function(){\n    console.log('1')\n})\n\nnew Promise(function(resolve){\n    console.log('2')\n    resolve()\n}).then(function(){\n    console.log('3')\n})\n\nconsole.log('4')\n```\n\n问：控制台以什么样的顺序打出console.log中的数字。\n\n半桶水晃荡的前端（我）会说： 2 / 4 / 1 / 3\n这是错的！\n\n## js执行机制\n\n关键在于js的执行机制\n\n先来看图\n\n![2.jpg](/images/eventloop/2.jpg)\n在js中：\n- 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\n- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n也就是说，在上面一节的代码中，这两个同步任务会先被执行：\n```javascript\nnew Promise(function(resolve){\n    console.log('2')\n    resolve()\n})\n\nconsole.log('4')\n```\n\n所以控制台会先打出 2 和 4\n\n至于 1 和 3谁会先被控制台打出，就要看下图了：\n\n![1.jpg](/images/eventloop/1.jpg)\n\n宏任务微任务这两个名词的解释是：\n- macro-task(宏任务)：包括整体代码script，setTimeout，setInterval\n- micro-task(微任务)：Promise，process.nextTick\n\n先执行宏任务，结束后判断有没有微任务，没有就执行宏任务，有就执行微任务，最后都是开始执行新的宏任务，一直循环。\n\n以这个代码为例：\n\n```javascript\nsetTimeout(function(){\n    console.log('1')\n})\n\nnew Promise(function(resolve){\n    console.log('2')\n    resolve()\n}).then(function(){\n    console.log('3')\n})\n\nconsole.log('4')\n```\n\n- 这段代码片段是宏任务，从上到下执行\n- 碰到setTimeout， 将其注册分发到宏任务Event Queue。\n- 碰到new Promise， 执行，控制台打出 ‘2’，then函数注册分发到微任务Event Queue。\n- 碰到console.log ,执行控制台打出 ‘4’\n- 一个宏任务结束，查看有没有微任务可以执行，好，有一个then函数在微任务Event Queue里，执行，控制台打出 ‘3’\n- 一轮事件循环结束，从新的宏任务Event Queue开始，也就是setTimeout,控制台打出 ‘1’。\n\n## 好记性不如烂笔头，特此记录！\n\n\n\n\n\n\n","tags":["javascript"]},{"title":"翻译小程序踩坑记录","url":"/2019/03/08/记-翻译小程序/","content":"\n# 初步了解小程序\n\n> 小程序的结构\n\n小程序其实还是在用html，css，js来组织页面，只是名字变成了wxml，wxss(小程序没有wxjs，只有js)，在使用上和html，css也有一点差别\n小程序没有dom树和window对象，没有办法使用相关的api。\n小程序提供了各类组件，像picker，checkbox，map等组件.\n\n\n\n\n\n\n\n\n\n","tags":["小程序"]},{"title":"关于Cookie和Session以及响应头","url":"/2018/12/26/关于Cookie和Session以及响应头/","content":"# Cookie 和 Session 的区别\nCookie是服务器通过Set-Cookie响应头给浏览器的一串字符串\n浏览器访问相同域名时必须带上这段字符串\n浏览器在一段时间内要保存Cookie\nCookie的大小大概在4KB左右\n————————————————————\nSession是服务器保存的\n服务器通过Cookie给浏览器一个SessionID\n服务器有一块内存保存了类似于 { SessionID：Session }的哈希数据结构\n浏览器访问服务器时，服务器读取SessionID，根据ID找到对应的Session，服务器就可以读取Session中的用户信息了\n# Cookie 和 LocalStorage 的区别？\nCookie是服务器通过Set-Cookie响应头给浏览器的一串字符串\n浏览器访问相同域名时必须带上这段字符串\n浏览器在一段时间内要保存Cookie\nCookie的大小大概在4KB左右\n——————————————————————————————————————\nLocalStorage是在浏览器本地保存的（可能保存在C盘之类的地方）并且和HTTP无关\n只有在相同域名的页面才能互相读取LocalStorage，但是没有同源策略那么严格\nLocalStorage如果用户不特意清除会永远保存\nLocalStorage的大小大概在5MB左右\n# LocalStorage 和 SessionStorage 的区别\nLocalStorage是在浏览器本地保存的（可能保存在C盘之类的地方）并且和HTTP无关\n只有在相同域名的页面才能互相读取LocalStorage，但是没有同源策略那么严格\nLocalStorage如果用户不特意清除会永远保存\nLocalStorage的大小大概在5MB左右\n————————————————————————————————————————\nSessionStorage和LocalStorage差不多，但是SessionStorage关闭页面就会消失\n# Cookie 如何设置过期时间？\n两种方法，设置Cache-Control或者设置Expires,设置Expires是老方法，现在推荐使用Cache-Control\n\nCache-Contro:\n```javascript\nresponse.setHeader('Cache-Contro','max-age=30')\n```\nExpires：\n```javascript\nresponse.setHeader('Expires','Wed, 26 Dec 2018 06:59:19 GMT')\n```\n两者的区别是前者规定过了多少时间后失效，后者是到了某个时间之后失效(后者指的是本地时间)\n# 如何删除 Cookie？\n可以用js来删除，也可以用户通过浏览器的清除缓存选项，把清除Cookie勾选上来删除。\n还有Cookie过期了就自动删除了\n# Cache-Control: max-age=1000 缓存 与 ETag 的「缓存」有什么区别？\nCache-Control: max-age=1000\n在一千秒后Cookie会过期，在此期间除了第一次访问外，浏览器会直接从内存获取文件而不是通过Http请求，这个过程产生0流量\n在一千秒后还得通过Http请求获取文件\n——————————————————————————————\nETag相当于一个版本号，浏览器持有的这个版本号和服务器端一样的话就不用再重新下载文件了，但是和服务器端对比版本号这个过程会产生流量。\n","tags":["javascript"]},{"title":"call、apply、bind 的用法","url":"/2018/11/27/call、apply、bind-的用法/","content":"\ncall、apply、bind这三个的作用都是改变函数运行时this的指向\n\n## call\ncall方法第一个参数是要绑定给this的值,从第二个值开始是传入的参数\n```javascript\nfunction fun(a){\n    console.log(this,a)\n}\n\nfun.call(undefined,1)\n```\n在开发者工具输入以上代码会出现window和1，这是因为浏览器在默认情况下如果第一个参数是null或者undefined,this就会是window。使用严格模式(use strict)才会是undefined。\n\n输入多个参数的函数是这样的：\n```javascript\nfunction fun(a,b,c){\n    console.log(this,a,b,c)\n}\n\nfun.call(undefined,1,2,3) // console显示1 2 3\n```\n\n## apply\napply方法的用法和call方法差不多，不过apply方法的第二个参数是一个参数数组\n```javascript\nvar arr = [1,2,3,89,46]\nvar max = Math.max.apply(null,arr)  //arr是一个数组，函数运行结果是89\n```\n\n假设有两个个函数fn1，fn2，它们的作用是一样的,call和apply两种方法的对比是这样的：\n```javascript\nfn1.call(undefined,1,2,3,4,5)\nfn2.apply(undefined,[1,2,3,4,5])\n```\n## bind\nbind方法call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表，区别在于bind方法返回值是函数以及bind接收的参数列表的使用。\n```javascript\nvar obj = {\n    name: 'Dot'\n}\n\nfunction printName() {\n    console.log(this.name)\n}\n\nvar dot = printName.bind(obj)\nconsole.log(dot) // function () { … }\ndot()  // Dot\n```\nbind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 printName 中的 this 并没有被改变，依旧指向全局对象 window。\n\n```javascript\nfunction fn(a, b, c) {\n    console.log(a, b, c);\n}\nvar fn1 = fn.bind(null, 'Dot');\n\nfn('A', 'B', 'C');            // A B C\nfn1('A', 'B', 'C');           // Dot A B\nfn1('B', 'C');                // Dot B C\nfn.call(null, 'Dot');      // Dot undefined undefined\n```\ncall 是把第二个及以后的参数作为 fn 方法的实参传进去，而 fn1 方法的实参实则是在 bind 中参数的基础上再往后排。","tags":["javascript","语法"]},{"title":"易于理解的闭包","url":"/2018/11/26/易于理解的闭包/","content":"\n## 闭包是啥\nMDN官方解释：闭包是函数和声明该函数的词法环境的组合。\n\n在js中，函数内部可以读取到全局变量的值，但在函数外部无法读取函数内部的值\n```javascript\nfunction f1(){\n    var n =100\n}\n\nconsole.log(n) //n is not defined\n```\n\n但在js中可以这样\n```javascript\nfunction f1(){\n    var n =100\n    function f2(){\n　      console.log(n); \n　  }\n    return f2\n}\n\nvar result = f1()\nconsole.log(result()) // 100 \n```\n\n在上面的代码段，函数f2可以读取到函数f1的变量n，这时把函数f2作为返回值，就可以在f1外部读取到变量n了。\n\n** 简单地说，闭包是指有权访问其他函数作用域中的变量的函数。**\n再看一个例子↓\n```javascript\nfunction add(a){\n    function wrapper(b){\n        return a+ b\n    }\n    return wrapper \n}\n\ntemp = add(1)\nconsole.log(temp(2)) // 3\n```\n上面的代码段中，变量a和b始终保持在内存中\n\n「闭包」，是指拥有多个变量和绑定了这些变量的环境的\n表达式（通常是一个函数），因而这些变量也是该表达式\n的一部分。\n\n## 闭包的用处\n最大的用处当然是面试...（手动滑稽）\n\n闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n所有的应用围绕在这两点展开\n\n链式调用就是应用闭包的一个典型例子\n```javascript\nvar Obj = {\n    a: 1,\n    func: function(){\n        this.a += 1;\n        return this\n    }\n}\nObj.func().func();\nconsole.log(Obj.a);    //3\n```"},{"title":"移动端适配的要点","url":"/2018/11/25/移动端适配的要点/","content":"\n## 要点1 meta viewport\n让浏览器不要缩放,在html加入以下代码\n ```html\n<meta name=\"viewport\" content=\"width=device-width,height=device-height,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n   ```\n\n## 要点2 媒体查询\n使用css media query，为不同宽度的设备定制不同的css样式\n\n##  要点3 动态 rem方案\nrem是一个单位，代表根元素的 font-size 大小。\nrem === html的fontsize。\n\n动态rem方案顾名思义要用到rem。\n\n为什么用动态rem方案不用百分比布局？\n因为百分比布局没有办法让高度和宽度相配合，宽度为百分比的话，高度也写百分比是不起作用的。\n\n动态rem方案的核心思想是等比例缩放，解决高度和宽度配合的问题\n\n** 通过javascript让 （1rem） = （html的fontsize） = （页面的宽度 width） ** \n\n下面是简单版本的js代码\n\n```javascript\nvar pageWidth = window.innerWidth\ndocument.write('<style>html{font-size:' + pageWidth  + 'px;}</style>')\n```\n上面的代码使 1rem === 页面的宽度 width\n这样就可以在像下面这样写css，让div宽高配合。\n\n```css\ndiv {\n    height:0.5rem;\n    width:0.5rem\n    margin:0.25rem auto;\n}\n```\n不同的设备运行代码得到的rem是不同的\n因为现在的rem和设备屏幕大小有关，div在所有设备都可以保持1比1的比例\n"},{"title":"css（1）","url":"/2018/11/21/css（1）/","content":"## 速记\n\n1. 竖直方向上的margin会合并\n但是 加上\nOverflow:hidden\nborder-top:1px\npadding-top:1px\ndisplay:inline-block\ndisplay:table\ndisplay:flex的话就不会合并\n2. display:list-item\n元素li本来是有小圆点的\n因为它默认是display:list-item\n改了display圆点会消失\n\n3. position:absolute会改变元素的display\n原先的display:inline或display:inline-block，会变成display:block\n\n4. fixed定位的元素\n如果父元素有transform:scale(0.9)\n那么fixed定位的元素也会缩小，并且相对于父元素定位\n\n## 请写出一行文本过长就变成省略号的例子\n```html\n<!DOCTYPE html>\n<html lang=\"zh-hans\">\n\n<head>\n    <title></title>\n    <style>\n        .test {\n            width: 80px;\n            text-overflow: ellipsis;\n            overflow: hidden;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"test\">\n        asdp;oqwejaskljfdnas;lfoqjewrfqwraqertgataertga\n    </div>\n</body>\n\n</html>\n```\n\n## 请写出「姓名」与「联系方式」两端对齐的例子\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-Hans\">\n\n<head>\n    <title></title>\n    <style>\n        span {\n            border: 1px red solid;\n            width: 5em;\n            display: inline-block;\n            text-align: justify;\n        }\n\n        span::after {\n            content: '';\n            display: inline-block;\n            width: 100%;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"test\">\n        <span>姓名</span> <br>\n        <span>联系方式</span>\n    </div>\n</body>\n</html>\n```\n\n## 请写出一个高 40px 的 div，里面的文字垂直居中\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-Hans\">\n\n<head>\n    <title></title>\n    <style>\n        .test {\n            line-height: 24px;\n            padding: 8px;\n            outline: 1px red solid;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"test\">我是文字</div>\n</body>\n</html>\n```\n\n## 请写出多行文本超出部分变成省略号的例子\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-Hans\">\n\n<head>\n    <title></title>\n    <style>\n        .test {\n            border: 1px red solid;\n            display: -webkit-box;\n            -webkit-line-clamp: 3;\n            -webkit-box-orient: vertical;\n            overflow: hidden;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"test\">c\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n        z\n        x\n        c\n        q\n        a\n        w\n        e\n        r\n        a\n        s\n        f\n        z\n        x\n        c\n        v\n        f\n        z\n        x\n    </div>\n   \n</body>\n\n</html>\n```","tags":["css"]},{"title":"来写一写jquery","url":"/2018/11/13/来写一写jquery/","content":"\n## 1.初次尝试\n\n第一个版本，简单地使用function声明函数,使用官方api封装两个函数\n\n```javascript\nfunction getSiblings(node) {\n    //获得node的兄弟节点\n    var allChildren = node.parentNode.children\n\n    var array = {\n        length: 0\n    }\n\n    for (let i = 0; i < allChildren.length; i++) {\n        if (allChildren[i] !== node) {\n            array[array.length] = allChildren[i];\n            array.length += 1\n        }\n    }\n    return array\n}\n\nfunction toogleClass(node, classes) {\n    //开关函数，对于node，有class就移除class，没有class就添加class\n    for (let key in classes) {\n        var methodName = classes[key] ? 'add' : 'remove'\n        node.classList[methodName](key)\n    }\n}\n```\n这样做有很大的缺点，万一别人也定义了一个getSiblings函数怎么办，听谁的？\n所以要继续改进\n\n## 2.一鼓作气 \n为了解决函数名字重复的问题，在第一个版本的基础上，我们使用命名空间。\n```javascript\nwindow.ycdom = {}\nycdom.getSiblings = getSiblings\nycdom.toogleClass = toogleClass\n\n//这样调用函数的时候就是：\nvar node = document.querySeletor('#x')\nycdom.getSiblings(node)\n```\n使用命名空间还可以提高辨识率，防止你写辣鸡代码 (。・∀・)ノ\n## 3.再战江湖 \n在上一个版本ycdom.getSiblings(node)这样的代码太长，而且视觉上node在后面，看代码时不容易知到node是哪个节点。\n\n第三个版本，在Node原型上添加自己封装的函数。\n```javascript\nNode.prototype.getSiblings = function () {\n    allChildren = this.parentNode.children\n    //获得node的兄弟节点\n    var array = {\n        length: 0\n    }\n\n    for (let i = 0; i < allChildren.length; i++) {\n        if (allChildren[i] !== this) {\n            array[array.length] = allChildren[i];\n            array.length += 1\n        }\n    }\n    return array\n}\n\nNode.prototype.toggleClass = function (classes) {\n    //开关函数，对于node，有class就移除class，没有class就添加class\n    for (let key in classes) {\n        var methodName = classes[key] ? 'add' : 'remove'\n        this.classList[methodName](key)\n    }\n}\n```\n现在我们可以这样使用了:\n**var node = document.querySeletor('#x')**\n**node.getSinlings()**\n这样用起来更方便，更舒服，但是在原型上添加东西的话是一种破坏，多人协作每个人都往原型添点东西不用多久就天下大乱了。还得改进。\n## 4.最终版本\n```javascript\nwindow.jQuery = function (nodeOrSeletor) {\n    let nodes = {}\n    if (typeof nodeOrSeletor === 'string') {\n        let temp = document.querySelectorAll(nodeOrSeletor)\n        for (let i = 0; i < temp.length; i++) {\n            nodes[i] = temp[i]\n        }\n        nodes.length = temp.length\n    } else if (nodeOrSeletor instanceof Node) {\n        nodes = {\n            0: nodeOrSeletor,\n            length: 1\n        }\n    }\n\n\n    nodes.addClass = function (classes) {\n        //当classes不是数组时，会报错，所以为了健壮性写了两段代码处理不同情况\n        //这里默认参数是字符串或数组\n        if (typeof classes === 'string'){\n            for (let i = 0; i < nodes.length; i++) {\n                nodes[i].classList.add(classes)\n            }\n        } else {\n            classes.forEach(value => {\n                for (let i = 0; i < nodes.length; i++) {\n                    nodes[i].classList.add(value)\n                }\n            })\n        }\n    } \n    nodes.getText = function () {\n        var texts = []\n        for (let i = 0; i < nodes.length; i++) {\n            texts.push(nodes[i].textContent)\n        }\n        return texts\n    }\n    nodes.setText = function (text) {\n        for (let i = 0; i < nodes.length; i++) {\n            nodes[i].textContent = text\n        }\n    }\n\n    return nodes\n}\n\n\nwindow.$ = jQuery //相当于把jQuery命名为$\n```\n\n我们没有修改Node的原型。\n定义了jQuery函数，这个函数返回对象nodes，nodes自带三个方法：getText setText addClass，最后一行\n```javascript\nwindow.$ = jQuery 相当于把jQuery命名为$\n```\n可以像下面这样使用\n```javascript\nvar $div = $('div')\n$div.addClass('red') // 可将所有 div 的 class 添加一个 red\n$div.setText('hi') // 可将所有 div 的 textContent 变为 hi\n```","tags":["javascript","jquery"]},{"title":"this 的指向","url":"/2018/11/11/this-的指向/","content":"在做下面两道题时有疑惑\n\n后来运行了代码就清楚了，特此记录\n\n\n\n```javascript\nwindow.name = 'window name'\n\nvar obj = {\n    name: 'ycngu',\n    f: function () {\n        console.log(this.name)\n    }\n}\n\nobj.f() // 'ycngu'\n```\n```javascript\nwindow.name = 'window name'\n\nlet obj2 = {\n    name: 'obj name',\n    f: () => {\n        console.log(this.name)\n    }\n}\n\nobj2.f() // 'window name'\n```\n上面两个函数的执行结果分别是'ycngu'和'window name'\n\n第一个函数obj调用的时候实际上是这样的\n\nobj.f.call(obj)\n\ncall的第一个参数就是this，在这里是obj\n\n第二个函数里f这个函数是箭头函数，函数调用时箭头函数里的this指向的是widow\n\n"},{"title":"jquery学习指北","url":"/2018/11/09/jquery学习指北/"},{"title":"DOM APi","url":"/2018/11/03/DOM-APi/","content":"注：以下文字有很多来自阮一峰老师的js教程\n## DOM\n\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\n\nDOM 的最小组成单位叫做**节点（node）**。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。\n\n节点的类型有七种。\n\n> Document：整个文档树的顶层节点\n> DocumentType：doctype标签（比如&lt;!DOCTYPE html>）\n> Element：网页的各种HTML标签（比如&ltbody>、&lta>等）\n> Attribute：网页元素的属性（比如class=\"right\"）\n> Text：标签之间或标签包含的文本\n> Comment：注释\n> DocumentFragment：文档的片段\n\n## Node\n\n浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。\n\nNode接口属的性具体如下\n>Node.nodeType\nNode.nodeName\nNode.nodeValue\nNode.textContent\nNode.baseURI\nNode.ownerDocument\nNode.nextSibling\nNode.previousSibling\nNode.parentNode\nNode.parentElement\nNode.firstChild，Node.lastChild\nNode.childNodes\nNode.isConnected\n\nNode接口的方法如下\n>Node.appendChild()\nNode.hasChildNodes()\nNode.cloneNode()\nNode.insertBefore()\nNode.removeChild()\nNode.replaceChild()\nNode.contains()\nNode.compareDocumentPosition()\nNode.isEqualNode()，Node.isSameNode()\nNode.normalize()\nNode.getRootNode()\n\n## Nodelist\n\nNodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。\n\n>Node.childNodes\ndocument.querySelectorAll()、document.getElementsByTagName()等节点搜索方法\n\nNodeList是伪数组，可以使用length属性和forEach方法。但是，它不是数组，它的原型链上没有Array.prototype，不能使用pop或push之类数组特有的方法。\n\n## HTMLCollection\nHTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历。\n\n返回HTMLCollection实例的，主要是一些Document对象的集合属性，比如document.links、docuement.forms、document.images等。\n\n**HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中。**\n\n## ChildNode 接口\n\n如果一个节点有父节点，那么该节点就继承了ChildNode接口。\n\nNode接口的方法如下\n> ChildNode.remove()\nChildNode.before()\nChildNode.after()\nChildNode.replaceWith()"},{"title":"js中的函数","url":"/2018/11/03/js中的函数/","content":"\n## 函数的五种声明方式\n\n1.具名函数\n```javascript\nfunction x(input1,input2){\n    return undefined\n}\n```\n\n2.匿名函数\n```javascript\nvar x = function  (input1, input2){\n    return undefined\n}\n\nx.name // 'x'\n```\n\n3.具名函数赋值\n```javascript\nvar x = function  y(input1, input2){\n    return undefined\n}\n\nx.name // 'y'\n```\n\n\n4window.Function\n\n```javascript\nvar x = new Function('x','y','return x+y')\nx.name // \"anonymous\"\n```\n\n\n5箭头函数\n\n```javascript\nf= (x,y)=>{return x+y}\n```\n\n\n\n## js不一致性 \n\n```javascript\nfunction y(){}\nconsole.log(y) //y(){}'\n```\n```javascript\nvar x = function y(){}\n\nconsole.log(y) //报错\n```\n\n## 常见考点\n\n### 作用域\n```javascript\nvar a = 1\nfunction f(){\n    function f1(){\n        var a = 3\n    }\n    var a = 2\n}\n\nf.call()\nconsole.log(a) //1\n```\nlog结果是1\n\n```javascript\nvar a = 1\nfunction f(){\n    function f1(){\n        var a = 3\n    }\n    var a = 2\n}\n\nf.call()\nconsole.log(a) //1\n```\n\n-------\n\n\n### 变量提升\n```javascript\nfunction f(){\n    console.log(a)\n    var a = 2\n}\n\nf.call() // a是undefined\n```\n\n这里涉及到变量提升，变量提升后的代码是这样的\n```javascript\nfunction f(){\n    var a\n    console.log(a)\n    a = 2\n}\n\nf.call() // a是undefined\n```\n### 闭包\n\n```javascript\nfunction sum(a){\n    function wrapper(b){\n        return a + b\n    }\n    return wrapper\n}\n\nsum.call(4).call(3) // 7\no = sum(8) //返回一个函数\no(2)  // 10\n```\n\n闭包就是一个函数能引用到它作用域外的变量\n这里 函数 o 依然可以引用到 8\n\n\n\n","tags":["javascript","函数"]},{"title":"原型与原型链","url":"/2018/10/16/原型与原型链/","content":"## 为什么要有原型（proto）\n\n我们知道，**每一个number**都有一个 **.toString方法**,\n\n```javascript\n(1).toString // '1'\n(2).toString // '2'\n(3).toString // '3'\n(4).toString // '4'\n(5).toString // '5'\n(6).toString // '6'\n```\n\n想一想，**每一个number**都有一个 **.toString方法**,那这个方法是怎么储存的呢？\n\n是每创建一个number就给这个number一个 **.toString方法**吗？\n<!--more-->\n假设我们以后有100万个nuber要创建，那么我们就要给100万个number 100万个 **.toString方法**，这显然是很大的开销，这是不可接受的。\n\n这时候就需要 原型（proto）来拯救世界了。\n\n这些number的 **.toString方法**长得都一个样，那么我们应该用一个仓库把 .toString方法装起来,等到要用的时候，所有number到这个仓库去取就行了，这个仓库就是 **__proto __** 。\n\n创建number的时候，把这个__proto __赋给number（也就是说把同一个__proto __仓库给新创建的number），这样我们建了一个仓库，却可以给所有number用。\n\n有仓库当然要使劲用，所以这个 __proto __ 仓库不仅装有 **.toString方法**，还有valueOf，toFixed等一系列乱七八糟的东西。\n\n![1.jpg](/images/原型与原型链/1.png)\n\n## 原型与原型链\n\n上面把 原型（proto）比喻为一个仓库，是为了说明为什么要有proto，其实还可以做这样的比喻：\n\n小明的原型是人 ，人的原型是动物\n\n小明有四肢和五脏六腑，因为小明的原型（proto）是人，人就必须要有四肢和五脏六腑（类比 number的 __proto __ 有**.toString方法**），人是动物，必须要会运动。\n\n鹦鹉的原型是鸟， 鸟的原型是动物。\n\n鹦鹉有翅膀，因为鹦鹉的原型是鸟，鸟就必须要有翅膀，鸟是动物，所以鸟会运动。\n\n鹦鹉和小明的原型链分别是\n\n鹦鹉 -> 鸟-> 动物\n小明 -> 人-> 动物\n\n而 1 这个number的原型链是\n\n1 -> number -> object \n\n1是number 而number 是 object\n\n在控制台测试一下。\n\n----\n![2.jpg](/images/原型与原型链/2.png)\n\n看上图，1的 __proto __ 显示它的构造函数是number\n\n（1的 __proto __） 的 __proto __显示 （1的 __proto __） 的构造函数是Object\n\n那么 \n\n```javascript\n(1).__proto__.__proto__.__proto__ //null\n```\n\n是啥呢，结果是null，null就是这个原型链的终点。\n\n完整的原型链应该是:\n\n1 -> number -> object -> null\n\n至于为什么是null ，[点这里](https://segmentfault.com/q/1010000005795507/a-1020000005813048)了解详情\n\n## 令人迷糊的 \\_\\_proto\\__  和 prototype\n\n先看[这一篇文章](https://segmentfault.com/q/1010000005795507/a-1020000005813048)（赞美方方~）\n\n然后关于\\_\\_proto\\__  和 prototype 只需记住下面这一条公式就完事了\n\n```javascript\n对象.__proto__ === 构造函数.prototype\n```\n\n问题：\n\nFunction是对象吗？\n\n是\n\nFunction是函数吗？\n\n是\n\n下面套入公式\n```javascript\nFunction.__proto__ === Function.prototype //true\n```\n结果为true\n\n一切都是公式的变形。","tags":["javascript","原型","原型链"]},{"title":"JS里的数据类型转换","url":"/2018/10/14/JS里的数据类型转换/","content":"## js数据类型\n复习\n上回说过，javascript有七种数据类型，分别是：\n * number (小数和整数，如1，1.2324)\n * string （字符串，如 'hello'）\n * boolean （true和false） \n * symbol (es6新数据类型)\n * object (注意array和function都是object)\n * null （空值）\n * undefined （未定义）\n<!--more-->\n那它们之间怎么转换呢？\n## string\n可以使用obj.toString(),也可以加上一个空字符串或使用String函数，但obj.toString()有局限性。\n```javascript\n//number\n1.toString() //'1'\n\n//boolean\nb = true\nb.toString() //'true'\nb + '' //'true'\n\n//symbol 这个不用记\ns = Symbol('Symbol')\ns.toString() // \"Symbol(symbol)\"\n\ns + '' //Cannot convert a Symbol value to a string\n\n//null\nnull.toString() // TypeError: Cannot read property 'to' of null\n\nnull + '' // \"null\"\n\n//undefined\nundefined.toString() //Cannot read property 'toString' of undefined\n\nundefined + '' //\"undefined\"\n\n//object\nobject = {name:'ycngu'} //\"[object Object]\"\n\nobject + '' //\"[object Object]\"\n```\n\n## boolean\n\nBoolean函数用来返回布尔值\njs中有五个值要记住，这五个值输入Boolean函数会返回false,称为**falsy**\n（还有其他值，但记住这些就够了 ）\n分别是：\n```javascript\nBoolean(null)\nBoolean(undefined)\nBoolean('') // 空字符串\nBoolean(0) // number\nBoolean(NaN) // number\n//以上全部返回false\n```\n**要注意的是，所有的Object都是true,包括function和array**\n```javascript\nfunction f(){}\narr = []\nobj = {}\nBoolean(f) //函数\nBoolean(arr) //数组\nBoolean(obj) //对象\n//以上全部返回true\n```\n有一种偷懒方法可以方便的得知true和false\n```javascript\n!! true // true\n!! {} // true\n!! 0 //false\n```\n## number\n四种方法\n- Number()\n- parseInt()\n- parseFloat()\n- 减去0\n- 取正 +'1.23' // 1.23\n一般都是把string转为number\n下面说一下值得提的点\n```javascript\ntrue + true // 等于2 ！！！\ntrue * 3 // 等于3 \n//也就是说 true和数字进行计算的时候等于1\n\nfalse + 3 //等于 3\nfalse * 3 //等于0\n//也就是说 false和数字进行计算的时候等于0\n\nundefined + 0 // NaN\nnull + 1 // 1\n\nparseInt('123s') // 123\nparseInt('123lsdasd1213') // 123\n//parseInt函数有两个参数，一个是解析的值，另一个是确定几进制的值，默认是10进制，parseInt会尽力解析值，直到不能解析，所以这里得到的是 123\n```\n\n\n\n","tags":["javascript","数据类型转换"]},{"title":"javascript数据类型","url":"/2018/10/13/js数据类型/","content":"\n\n## js数据类型\njavascript有七种数据类型，分别是：\n * number (小数和整数，如1，1.2324)\n * string （字符串，如 'hello'）\n * boolean （true和false） \n * symbol (es6新数据类型)\n * object (注意array和function都是object)\n * null （空值）\n * undefined （未定义）\n<!--more-->\n## number\nJavaScript 内部，所有数字都是以64位浮点数形式储存,包括整数。\n所以会有下面的情况\n```javascript\nvar a = 1\nvar b =1.0\n\na == b //true\n\n1.1 - 1 // 0.10000000000000009\n//1.1 以64位浮点数形式储存，所以会出现这样的结果\n```\n**so注意,涉及到小数的运算都要特别小心**\n\nNaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合.\n```javascript\nNaN\n\n1 * 'kk' //NaN\n```  \n\n以下是各进制在js中的表示方法\n```javascript\n24//十进制\n1.3e4//十进制，科学计数法\n0b11//二进制，0b开头\n011//八进制，以0开头\n0xff//十六进制，0x开头\n```\n\n## string\n字符串有多种定义的方式\n```javascript\n'hello' //用单引号包起来\n\"world\" //用双引号包起来\n\n`hello\nworld` //多行字符串写法一，用反引号包起来 \n```\n问：反引号括起来的helloworld的length是多少？\n答：11，因为 **包含了回车！** 千万要注意。\n\n```javascript\n//多行字符串写法二\nvar w1 = '12345 \\    \n          67890'\n\nvar w2 = '12345 \\\n          67890'\n```\n问：上面的代码中，w1和w2有什么区别？\n答：按 ctrl+a ，你会看到 w1的12345后面紧跟着空格，w2则没有，w1会报错！！！坑死人不偿命\n\n如果一定要换行，正确的写法是\n\n```javascript\nvar w1 = '12345' +\n         '67890'\n```\n\n## boolean\nboolean只有true和false两个值\n通常和if else 和 && ||等运算符一起使用\n```javascript\nif(true){\n    //执行这里的代码\n}\n\nif(false){\n    //不执行这里的代码\n}\n```\n\n```javascript\ntrue && false //false\n\ntrue || false //true\n```\n\n## null 和 undifined\n\n这两个都表示什么都没有\njs之父承认这是他设计错了（手动滑稽）\n\n```javascript\nvar a\n\n// a的值为undefined\n```\n\n> **如果一个变量没有赋值，会被js赋值为undefined\n如果有一个object对象，现在不想给值，推荐初始化成null\n如果有一个非object对象，现在不想给值，推荐初始化成undefined**\n\n## object\n\n以上都属于基本类型，而object是复杂类型，由简单类型组成\n\n```javascript\nvar name = 'joe'\nvar age = 18\nvar gender = 'male'\n//简单类型\n\nvar person = {\n    name: 'joe',\n    age: 18,\n    gender: 'male'\n}\n//复杂类型,由简单类型组成\n```\n**注意这里有个坑**\n```javascript\nvar name = 'xxxx'\nperson[name]\nperson['name']\n```\n问：person[name]和person['name']的值分别是多少？\n答：前一个是undefined，后一个是 'joe'\n\nperson[name] //实际上是person['xxxx']\n\n\n```javascript\nfunction f(){}\n\ntypeof(f) //'function'\n```\n**如果用typeof函数去测f,那么会显示f的类型是function,实际上f的类型是objcet,谨记**\n## symbol\n> ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。\n\n以上是阮一峰老师的解释\n更多知识请猛戳以下两个链接\nhttp://es6.ruanyifeng.com/#docs/symbol\nhttps://zhuanlan.zhihu.com/p/22652486\n\nsymbol类型通过symbol函数创建\n```javascript\nlet a = symbol()\n```\nSymbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n```javascript\nlet s1 = Symbol('foo');\nlet s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n```\n\n","tags":["javascript"]},{"title":"css布局","url":"/2018/10/03/css布局/","content":"\n## 左右布局\n\n左右布局常用float\n\n**css:**\n```css\n    .clearfix::after{\n        content: '';\n        display: block;\n        clear: both;\n    }\n\n    .child1{\n        float:left;\n    }\n\n    .child2{\n        float:right;\n    }\n```\n**html:**\n```html\n    <div class=\"parents clearfix\">\n        <div class=\"child1\"></div>\n        <div class=\"child2\"></div>\n    </div>\n```\n\n这样的左右布局关键点在于给子元素添加左右浮动，给父元素添加clearfix\n\nclearfix::after 是套路，记住就行了\n<!--more-->\n##左中右布局\n\n左中右布局：有圣杯布局和双飞翼布局。\n它们的特点都是左右两栏固定宽度,中间部分自适应。\n\n下面这个是圣杯布局\n**css:**\n```css\n    .container {\n        padding: 0 200px 0 220px;\n        overflow: hidden;\n    }\n\n    .left , .right , .middle {\n        float: left;\n        position: relative;\t\n        min-height: 130px;\n    }\n\n    .left{\n        width: 200px;\n        left: -200px;\n        margin-left: -100%;\n        background-color: green;\n    }\n\n    .middle{\n        width: 100%;\n        background-color: yellow;\n    }\n\n    .right{\n        width: 220px;\n        margin-left: -220px;\n        right: -220px;\n        background-color: blue;\n    }\n```\n**html:**\n```html\n    <div class=\"container\">\n        <div class=\"middle\"></div>\n        <div class=\"left\"></div>\n        <div class=\"right\"></div>\n    </div>\t\n```\n\n## 水平居中\n方法1\n在块级父容器中让行内元素居中\n```css\n    main{\n        text-align:center;\n    }\n```\n方法2\n块级元素居中\n```css\n    main{\n        margin: 0 auto;\n    }\n```\n方法3\n绝对定位实现水平居中\n```css\n    main{\n        position: absolute; \n        width: 宽度值; \n        left: 50%; \n        margin-left: -(宽度值/2);\n    }\n```\n方法4\n利用css3新特性transform\n```css\n    main{\n        position: absolute;\n        left: 50%;\n        transform: translateX(-50%);\n    }\n```\n\n## 垂直居中\n\n方法1\n把line-height设置为容器div的高度就能使文字垂直居中，假设div高50px\n```css\n    main{\n        line-height:50px;\n    }\n```\n\n下面是抄的河大博文，先说一句河大牛逼！（只抄了我认为用起来很爽的）\n细节请看：http://note.codermagefox.com/blog/post/magefox/centerItvertically\n\n方法2\n```css\n    main{\n        position:absolute; /*绝对定位*/\n        top: 50%;/*向下移动父元素高度一半*/\n        left:50%;/*向右移动父元素宽度一半*/\n        transform: translate(-50%,-50%);\n    }\n```\n方法3\n使用VH\n```css\n    main{\n        position:absolute; /*绝对定位*/\n        top: 50%;/*向下移动父元素高度一半*/\n        left:50%;/*向右移动父元素宽度一半*/\n        transform: translate(-50%,-50%);\n    }\n```\n方法4\n用flex\n```\n<style>\n    body{\n        display: flex;\n        min-height: 100vh;\n        margin: 0;\n    }\n    main{\n        margin:auto 0 auto 0;\n    }\n</style>\n<body>\n<main>\n    <h1>A quick brown fox jump over the lazy dog</h1>\n</main>\n```\n方法5\n在方法4基础上加上\n```css\n    main{ \n        align-self:center; \n    } \n```\n\n## 其它\n```css\n::nth-child(odd) // 选择单数的子元素\n::nth-child(even) // 选择双数的子元素\n::nth-child(1) // 选择第一个子元素\n```\n\n> * div高度由其内部文档流元素的高度总和决定\n\n> * 文档流：文档内元素的流动方向\n\n> * 内联元素从左往右流动，如果流动遇到阻碍，就换行\n块级元素，每一个块级元素占一行\n\n> * 内联元素  中文换行会被分，英文不会被分\nword-break属性用来解决这个事情\nWord-break:break-all / break-word\n\n> * 内联元素根据基线对齐\n\n> * 在html中回车会变成一个空格\n","tags":["javascript"]},{"title":"HTML常用标签","url":"/2018/10/01/HTML常用标签/","content":"# HTML常用标签\n> * a\n> * img\n> * div / span\n> * form\n> * input / button\n> * ol / ul / li\n> * iframe\n<!--more-->\n## a\n【标签】&lt;a&gt;&lt;/a&gt;\n【属性】\nhref：链接地址（要跳转到的页面的地址）\ntarget：目标，打开新网页的形式\n取值：\n     _blank：在新标签页中打开\n     _self：在自身页面中打开（默认值）\ntitle：鼠标放到链接上的提示\n\n## img \n【标签】&lt;img&gt;\t\n【属性】\n        src：图片地址（绝对/相对）\n        width：图像宽度\n        height：图像高度\n\n## div /span\n 【标签】&lt;div&gt;\t&lt;/div&gt;\t &lt;span&gt;\t&lt;/span&gt;\t\n  - div是 division的缩写,意思是**分隔**,span意思是**范围**\n  - div的display为block，span的display为inline\n  - div常用于页面布局，span用于划分行内段落\n  \n\n##  form / input / button\n form,表单最常见的就是注册和登陆表单，通常与input / button一起用\n【标签】&lt;form&gt;\t&lt;/form&gt;\t\n【常见属性】\n        action：提交的服务器地址\n        method：表单数据提交的方式，取值： get：明文提交/post：隐式提交\n        name：定义表单名称，JS用到的比较多\n        id： 独一无二的标识\n如：&lt;form action=\"url\" method=\"get/post\"&gt;\t &lt;/form&gt;\t\n\n  【标签】&lt;input&gt;\t\n  【主要属性】\n        type：根据不同的type属性值可以创建各种类型的输入字段\n        value：最终提交给服务器的值\n        name：控件的名称，提供给服务器使用，没有name，控件则无法提交\n        id：唯一标识，只能在当前页面使用，服务器不能用\n        disabled：禁用，不能被提交\n 【注意】\n    **input是空标签，button不是，空标签不能有子元素**\n\n【标签】&lt;button&gt;\t&lt;/button&gt;\t\n 【主要属性】\n   type：规定按钮的类型，有button，submit，reset\n   【注意】\n   **当button位于form内部时，如果不标明type,type属性自动设置为submit**\n   **当input的type为submit时，也可以提交表单**\n##  hr\n【标签】&lt;hr&gt;\t\n【属性】\n        size：尺寸，取值单位为 px（像素），可以省略\n        width：宽度，取值单位为px（像素）可以省略或百分比\n        color：颜色，取值自然颜色值\n        align：水平对齐方式，取值：left/center/right\n##  ol ，ul , li\n【标签】&lt;ol&gt;\t&lt;/ol&gt;\t &lt;ul&gt;\t&lt;/ul&gt;\t &lt;li&gt;\t&lt;/li&gt;\t\n - ol , Ordered List 有序列表\n - ul , Unordered List 无序列表\n -  li , List Item 列表项目\n\n一般是列表包裹着列表项\n如\n```\n<ol>\n  <li></li>\n  <li></li>\n  <li></li>\n</ol>\n\n<ul>\n  <li></li>\n  <li></li>\n  <li></li>\n</ul>\n```\n\n## iframe\n\niframe是嵌入页面，现在已经很少使用了\n【标签】&lt;iframe&gt;\t&lt;/iframe&gt;\t\n【主要属性】\nframeborder：规定是否显示框架周围的边框。\nsrc：\t规定在 iframe 中显示的文档的 URL。\nheight：规定 iframe 的高度。\nwidth:规定 iframe 的宽度。\n","tags":["javascript"]},{"title":"HTTP及curl","url":"/2018/09/29/HTTP及curl/","content":"## 前言\n\n![http.png](/images/HTTP及curl/1.png)\n\n客户端   通过  请求  向服务器发送数据\n\n服务器   通过  响应  向客户端返回数据\n<!--more-->\n## HTTP请求\nHTTP请求包括四个部分\n\n以下行 有1的是属于1的部分，有2的是属于2的部分以此类推\n\n1 动词 路径 协议/版本  (实际上是这样的 GET / HTTP/1.1)\n2 Key1: value1\n2 Key2: value2\n2 Key3: value3\n2 Content-Type: application/x-www-form-urlencoded\n2 Host: www.baidu.com\n2 User-Agent: curl/7.54.0\n3 \n4 <!DOCTYPE html>\n4<!--STATUS OK--><html> <head> 后面省略\n\n1) 请求行：是一个ASCII文本行，由三个标记组成--请求的HTTP方法、URL、HTTP版本，之间用空格分开{GET /lovobook/index.html HTTP/1.0}；\n2) 请求头：HTTP协议使用HTTP头来传递请求的元信息。HTTP头是一个用冒号分隔的名称/值对，冒号前面是HTTP头发名称，后面是HTTP的值；\n3) 空行： 发送回车符和退行，通知服务器一下不再有请求头；\n4) 消息体：  HTTP请求中带有查询字符串时，如果是GET方法，查询字符或表单数据附加值请求行中，则消息体中就没有内容；如果是POST方法，查询字符串或表单数据及添加在消息体中\n\n![image.png](//video.jirengu.com/xdml/image/2a58d0d9-bca5-4d5d-9fbb-228e52484371/2018-9-29-20-15-53.png)\n\n## HTTP响应\nHTTP响应包括四个部分\n\n1 协议/版本 状态码 原因短语 （实际上是这样的 HTTP/1.1 200 OK）\n2 Accept-Ranges: bytes\n2 Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform\n2 Connection: Keep-Alive\n2 Content-Length: 2443\n2 Content-Type: text/html\n2 Date: Tue, 10 Oct 2017 09:14:05 GMT\n2 Etag: \"5886041d-98b\"\n2 Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT\n2 Pragma: no-cache\n2 Server: bfe/1.0.8.18\n2 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/\n3\n4<!DOCTYPE html>\n4<!--STATUS OK--><html> <head> 后面省略\n\n1) 状态行：以一个状态行开头。状态行有HTTP协议版本、响应状态码和响应描述组成，之间用空格分隔；\n2) 响应头：与请求头一样；\n3) 空白行：最后一个响应头之后是一个空行，发送回车符和退行，表明以下不再有响应头；\n4) 消息体：要发送回BS的HTTP文档或其它要显示的内容等。Web服务器把要发送给客户端的文档信息放在消息体中。\n\n![image.png](//video.jirengu.com/xdml/image/2a58d0d9-bca5-4d5d-9fbb-228e52484371/2018-9-29-20-20-51.png)\n\n## 如果想详细了解HTTP状态码和各字段的意义\n请去看 《图解HTTP》！！！\n\n## 用Chrome开发者工具查看 HTTP 响应/请求 内容\n\n按键盘上的F12，会弹出开发者工具，输入网址，如 www.baidu.com 回车\n点击network，点击www.baidu.com，找到Request Headers，会看到如下场景\n\n![baidu1.png](//video.jirengu.com/xdml/image/2a58d0d9-bca5-4d5d-9fbb-228e52484371/2018-9-29-21-14-30.png)\n\n再点击view source，你就会看到请求内容了\n\n![baidu2.png](//video.jirengu.com/xdml/image/2a58d0d9-bca5-4d5d-9fbb-228e52484371/2018-9-29-20-55-43.png)\n\n查看响应内容同理，找到Request Headers ，点击view source\n\n\n![baidu3.png](//video.jirengu.com/xdml/image/2a58d0d9-bca5-4d5d-9fbb-228e52484371/2018-9-29-21-20-28.png)\n\n## 使用curl\ncurl是一种从服务器传输数据或向服务器传输数据的命令行工具\n用它可以像浏览器那样向服务器发起请求\n下面是curl命令的常用选项\n\n-A/--user-agent <string> 设置用户代理发送给服务器，即告诉服务器浏览器为什么\n    -basic 使用HTTP基本验证\n    --tcp-nodelay 使用TCP_NODELAY选项\n    -e/--referer <URL> 来源网址，跳转过来的网址\n    --cacert <file> 指定CA证书 (SSL)\n    --compressed 要求返回是压缩的形势，如果文件本身为一个压缩文件，则可以下载至本地\n    -H/--header <line>自定义头信息传递给服务器\n    -I/--head 只显示响应报文首部信息\n    --limit-rate <rate> 设置传输速度\n    -u/--user <user[:password]>设置服务器的用户和密码\n    -0/--http1.0 使用HTTP 1.0\n    -s --silent 静默模式,不显示错误和进度\n    -x 指定请求方式，如GET POST PUT等等\n    \n    例子\n    curl -s   -- \"https://www.baidu.com\"\n\n输入上面的命令后，curl会向百度的服务器发起GET请求（默认是GET）\n返回的报文主体如下\n![curl1.png](//video.jirengu.com/xdml/image/2a58d0d9-bca5-4d5d-9fbb-228e52484371/2018-9-29-21-47-47.png)\n\n\n\n\n\n\n\n\n\n\n","tags":["javascript"]},{"title":"git init/add/commit","url":"/2018/09/29/git-init-add-commit/","content":"# 一个网站查懂linux的命令\nhttps://explainshell.com/\n<!--more-->\n## git init \ngit init 会在当前目录下生成一个空的仓库，即.git文件夹\n.git文件夹默认是隐藏的，在linux下要用 ls -a 才能看到\n![gitinit.png](/images/gitinit.png)\n\n## git add\ngit add 会将文件提交到缓存区\n![gitadd.png](/images/gitadd.png)\n\n## git commit -v\ngit commit 将缓存区里的改动提交到本地的版本库\n![gitcommit.png](/images/gitcommit.png)\n\n加上-v后缀的解释\n![gitcommitv.png](/images/gitcommitv.png)\n我们来试一下\n![gitcommitv1.png](/images/gitcommitv1.png)\n![gitcommitv2.png](/images/gitcommitv2.png)\n回车，是下面这样子的\n![gitcommitv3.png](/images/gitcommitv3.png)\n\n\n","tags":["javascript"]},{"title":"ls cat mv touch 以及explainshell网站","url":"/2018/09/28/ls cat mv touch 以及explainshell网站/","content":"\n## explainshell\n这个网站用来查询各种命令及其后缀的作用\nhttps://explainshell.com/explain?cmd=ls+-af\n![explain1.png](/images/explain1.png)\n![explain2.png](/images/explain2.png)\n<!--more-->\n## ls\nls是list的缩写\nls的作用是列出当前目录下的文件及文件夹\n例子 当前目录下输入 ls 回车 \n![ls.png](/images/ls.png)\n## cat\ncat是catch的缩写\ncat的作用是在终端输出文件的内容\n例子 cat 1.txt 输出 hello\n\n![cat.png](/images/cat.png)\n\n## mv\nmv 是move的缩写，用来重命名/移动 文件或文件夹\n例子 mv 1.txt 2.txt\n![mv.png](/images/mv.png)\n## touch\ntouch用来创建一个文件\n例子 touch ycngu.txt\n\n![touch.png](/images/touch.png)\n\n\n","tags":["javascript"]}]